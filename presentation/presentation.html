<!DOCTYPE html>
<html>
  <head>
    <title>Binary Decision Diagrams</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <style type="text/css">
      /* Slideshow styles */
      /* Colors:
       * Red: #EA526F
       * Black: #070600
       * Off-white: #F7F7FF
       * Turquoise: #23BfD3
       * Blue: #279AF1
       */
      body {
        font-family: 'Roboto';
      }

      div.remark-slide-content {
        font-size: 24px;
      }

      .title {
        color: #279af1;
      }
      .statement {
        color: #279af1;
        font-size: 36px;
      }

      .subtitle {
        color: #EA526F;
      }

      h1 {
        color: #279af1;
      }

      ul li{
        margin-bottom: 24px;
      }
    </style>
  </head>
  <body>




    <!-- Creation of slides goes below. Slides are delineated with triple
        dashed lines: --- -->
    <textarea id="source">

class: center, middle

# .title[Binary Decision Diagrams]

---

# Boolean Expressions

---

# Boolean Expressions

.statement[$$ ( x \vee y) \wedge (\neg x \vee \neg y) $$]

---

# Boolean Expressions

.statement[$$ ( x \vee y) \wedge (\neg x \vee \neg y) $$]

- We'll use the convention of representing true and false as 1/0

---

# Boolean Expressions

.statement[$$ ( x \vee y) \wedge (\neg x \vee \neg y) $$]

- We'll use the convention of representing true and false as 1/0
- Variables can be assigned either 1 or 0
---

# Boolean Expressions

.statement[$$ ( x \vee y) \wedge (\neg x \vee \neg y) $$]

- We'll use the convention of representing true and false as 1/0
- Variables can be assigned either 1 or 0
- The overall expression is evaluated and results in either 1 or 0

--

- We can think of an expression as a function
  - `\(\ f : \{0,1\}^n \rightarrow \{0,1\} \)`

---

# Do boolean functions even come up anywhere useful?

--

Oh you bet!

--

- Many, many problems can be expressed as boolean functions

--

- They come up all the time in:

--

  - circuit design and formal verification

--

  - grapy theory

--

  - Combinatorial optimization

---

class: center, middle

## .subtitle[So how can we efficiently solve these things?]

---

class: center, middle

# `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

---

# Variable Ordering

## `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

--

- We'll first fix an ordering of the variables

--

  - `\( x < y \)`

--


This means we'll first consider what happens when we assign x.

--

Then see what happens when we assign y, <em>given</em> the previous assignment to x.

---

class: center

# `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

[graph of just x node here]

---

class: center

# `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

[graph of just x node here with edges here]

---

class: center

# `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

[graph x node + y nodes]

---

class: center

# `\( (x \vee y) \wedge (\neg x \vee \neg y) \)`

[Evaluated graph here]

---

# The resulting structure is called a Binary Decision Tree (BDT)

--

Terminology note: we call the 0 labeled edges the <em>low</em> edges, and 1 labeled
edges the <em>high</em> edges

--

- Pros:

--

  - Given the BDT for a function, we can test whether a given assignment is satisfying in
      `\( \Theta(n) \)` time!

--

- Cons:

--

  - We end up with `\( \Theta(2^n) \)` nodes :(

---
class: middle, center

# .subtitle[Let's make a few observations]

---

class: center

 [insert graph of x iff y and a iff b]

--

1. Some subtrees are identical

---

class: center

[insert OBDD of x iff y and a iff b]

---

# The result is called a Binary Decision Diagram

--

- Pros:

--

  - While still `\( O(2^n) \)` at worst in size, in practice these are usually much smaller
  than BDTs

--

- Cons:

--

  - It still leaves some structural properties we can improve upon...

---
class: center

# Redundant tests

[ insert graph of x1 or x3 with redundant x2 test]

--

The low and high edges of the x2 node <em>lead to the exact same result</em>

---

[ insert graph of x1 or x3 with redundant x2 node gone]

---


# <em>Reduced Ordered Binary Decision Diagrams</em> (ROBDD)


--

Note : Technically all of our structures thus far have been ordered

--

- Cons:

--

  - Still `\( O(2^n) \)` size in the worst case

--

- Pros:

--

  - A lot of expressions end up much, much smaller in practice

--

  - We can run simple graph algorithms to perform useful operations on the expression

--

  - We've gained the property of <em>canoncity</em>.

---

class: center

# Canoncity of ROBDDs

## For a fixed variable ordering, each boolean function has a canonical (or unique) representation as a ROBDD.

--

<em>Proof:</em> By induction on the number of variables.


---

## .title[Thanks to the canoncity property, we can:]

--

- check if an expression is a tautology (every possible assignment is satisfying)

--

- and check if an expression is unsatisfiable

--

in <em>CONSTANT</em> time!

--

We can also check if <b>two expressions are equal</b> in time proportional to the sizes
of their ROBDDs.

---
class: center

<iframe src="https://giphy.com/embed/5aLrlDiJPMPFS" width="480" height="558" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="http://giphy.com/gifs/jon-stewart-the-daily-show-5aLrlDiJPMPFS">via GIPHY</a></p>

---

class: center, middle

## .subtitle[ROBDDs are so useful, one assumes you mean them when you say BDD. We'll use that convention moving forward.]

---
Highly dependent on the variable ordering

TODO: Show example of same expression, different variables orderings here

But the problem of finding the best variable ordering is NP-hard!

---

# Display and Inline

1. This is an inline integral: `\(\int_a^bf(x)dx\)`
2. More `\(x={a \over b}\)` formulae.

Display formula:

$$e^{i\pi} + 1 = 0$$

.mermaid[graph TD
        A---B
        A-.->C
        B-->D
        C-->D]

---

# BDD Creation Framework

```java
public static void main(String args[]) {
    String myExpr = "(a | b) & (!a | !b)";
    BDD bdd = BDD.of(myExpr);
    System.out.println(bdd.getNumSolutions());
}
```

```
> 2.0
```
---

#The Vertex Cover Problem

 [vertex cover graph here]

--

- `\( x1 \rightarrow ( y1 \wedge y2 )\)`

--

- `\( x2 \rightarrow ( y1 \wedge y3 )\)`

--

- `\( x3 \rightarrow ( y2 \wedge y3 )\)`

--

- `\( y1 \rightarrow ( x1 \vee x2 )\)`

--

- `\( y2 \rightarrow ( x1 \vee x3 )\)`

--

- `\( y3 \rightarrow ( x2 \vee x3 )\)`

--

- `\( y1 \wedge y2 \wedge y3 \)`

    </textarea>








    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
    <script   src="https://code.jquery.com/jquery-2.2.4.min.js"   integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="   crossorigin="anonymous"></script>
    <script src="./mermaid.min.js"></script>
    <link rel="stylesheet" href="./mermaid.css">
    <script>mermaid.initialize({startOnLoad:true});</script>

    <script type="text/javascript">
      var slideshow = remark.create();

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });
      MathJax.Hub.Queue(function() {
          $(MathJax.Hub.getAllJax()).map(function(index, elem) {
              return(elem.SourceElement());
          }).parent().addClass('has-jax');
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
